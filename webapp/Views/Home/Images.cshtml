@{
    ViewData["Title"] = "Add Images";
}

<div class="row">
    <div class="col-md-10 col-lg-8">
        <h1 class="mb-3">Add and analyze images</h1>

        <div class="card mb-3">
            <div class="card-body">
                <div class="row g-2 align-items-center">
                    <div class="col-12 col-md-5">
                        <label class="form-label">Storage path</label>
                        <div class="form-control-plaintext" id="storagePath">@ViewBag.StoragePath</div>
                    </div>
                    <div class="col-12 col-md-5">
                        <label class="form-label">Input path</label>
                        <div class="form-control-plaintext" id="inputPath">@ViewBag.InputPath</div>
                    </div>
                    <div class="col-6 col-md-2">
                        <label for="dop" class="form-label">Threads</label>
                        <input id="dop" class="form-control" type="number" min="1" max="32" value="12" />
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">Day 0 — make sure that content is new</div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-2">
                    <button class="btn btn-outline-primary" id="btnDuplicate">Run DuplicateMarker</button>
                </div>
                <small class="text-muted">This will help to remove content which is not required for processing and embedding generation</small>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">Day 1 — Generate Md5 in file names and averages based on 512w previews</div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-2">
                    <button class="btn btn-outline-primary" id="btnMd5">Run Md5ImageMarker</button>
                    <button class="btn btn-outline-primary" id="btnAvg">Run AverageImageMarker</button>
                </div>
                <small class="text-muted">This will give you nice names and you can apply grouping of images if required.</small>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">Day 3 — Apply grouping against images via unique 4 chars folder name.</div>
            <div class="card-body">
                <button class="btn btn-outline-primary" id="btnExtractGroups">Run GroupFolderExtractor</button>
                <small class="text-muted">Group will help you to reduce cost of AI builder, once you applied grouping you can run this service to move images back.</small>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">Day 5 — Apply preview generator again. Detect faces</div>
            <div class="card-body">
                <button class="btn btn-outline-primary" id="btnFace">Run FaceHashBuilder</button>
                <small class="text-muted">Apply preview generator again but for all range of sizes.</small>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-header">Day 6 — AI analysis</div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-2">
                    <button class="btn btn-outline-primary" id="btnAi">Run AiContentQueryBuilder</button>
                    <button class="btn btn-outline-primary" id="btnAiAnswers">Run AiContentAnswerBuilder</button>
                </div>
                <small class="text-muted">Builds face embeddings, and AI content queries.</small>
            </div>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">Day 7 — AI Embeddings download</div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-2">
                    <button class="btn btn-outline-primary" id="btnEmbeddingDownloader">Run EmbeddingDownloader</button>
                </div>
                <small class="text-muted">Because we have text details, we can process it and download vector embeddings</small>
            </div>
        </div> 
        
        <div class="card mb-3">
            <div class="card-header">Day 8 — run tests against new folder</div>
            <div class="card-body">
                <div class="d-flex flex-wrap gap-2 mb-2">
                </div>
                <small class="text-muted">Day 8 run tests to verify all content processed correct and no any issues with that.</small>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-body">
                <div class="d-flex justify-content-between mb-2 align-items-center">
                    <div>
                        <strong>Progress:</strong>
                        <span id="progressText">0%</span>
                    </div>
                    <div>
                        <span class="badge bg-secondary" id="jobIdBadge" style="display:none"></span>
                    </div>
                </div>
                <div class="progress" role="progressbar" aria-label="Job progress" aria-valuemin="0" aria-valuemax="100">
                    <div id="progressBar" class="progress-bar progress-bar-striped" style="width: 0%">0%</div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">Live log</div>
            <div class="card-body">
                <!-- Virtualized log viewer -->
                <div id="logContainer" class="mb-0" style="height:300px; overflow:auto; position:relative; border: 1px solid rgba(0,0,0,.125); border-radius: .25rem;">
                    <div id="logSpacer"></div>
                    <pre id="logViewport" style="position:absolute; top:0; left:0; right:0; margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; line-height: 18px; white-space: pre; padding:.25rem .5rem;"></pre>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="~/lib/signalr/dist/browser/signalr.min.js"></script>
    <script>
        (function() {
            const bar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            // Virtual log elements
            const logContainer = document.getElementById('logContainer');
            const logViewport = document.getElementById('logViewport');
            const logSpacer = document.getElementById('logSpacer');
            const jobIdBadge = document.getElementById('jobIdBadge');
            const dopEl = document.getElementById('dop');

            const btnMd5 = document.getElementById('btnMd5');
            const btnDuplicate = document.getElementById('btnDuplicate');
            const btnAvg = document.getElementById('btnAvg');
            const btnFace = document.getElementById('btnFace');
            const btnExtractGroups = document.getElementById('btnExtractGroups');
            const btnEmbeddingDownloader = document.getElementById('btnEmbeddingDownloader');
            const btnAi = document.getElementById('btnAi');
            const btnAiAnswers = document.getElementById('btnAiAnswers');
            // No group sequence buttons: jobs start only when specific button is clicked

            let currentJobId = null;
            const connection = new signalR.HubConnectionBuilder()
                .withUrl('/hubs/jobstatus')
                .withAutomaticReconnect()
                .build();

            function setProgress(p) {
                p = Math.max(0, Math.min(100, p|0));
                bar.style.width = p + '%';
                bar.textContent = p + '%';
                progressText.textContent = p + '%';
            }

            // Virtual scrolling state
            const LOG_LINE_HEIGHT = 18; // must match CSS line-height in px
            const LOG_MAX_LINES = 50000; // cap to avoid unbounded memory
            let logLines = [];

            function renderLog() {
                const total = logLines.length;
                const viewH = logContainer.clientHeight;
                const scrollTop = logContainer.scrollTop;
                const start = Math.floor(scrollTop / LOG_LINE_HEIGHT);
                const visibleCount = Math.ceil(viewH / LOG_LINE_HEIGHT) + 10; // small buffer
                const end = Math.min(total, start + visibleCount);

                // Set total scrollable height via spacer
                logSpacer.style.height = (total * LOG_LINE_HEIGHT) + 'px';

                // Position the visible slice
                const offsetY = start * LOG_LINE_HEIGHT;
                logViewport.style.transform = `translateY(${offsetY}px)`;
                logViewport.textContent = logLines.slice(start, end).join('\n');
            }

            function scrollToBottom() {
                // Scroll to the very end; spacer height reflects total size
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            function addLog(msg) {
                const time = new Date().toLocaleTimeString();
                const shouldStickToBottom = (logContainer.scrollTop + logContainer.clientHeight) >= (logContainer.scrollHeight - 4);

                logLines.push(`[${time}] ${msg}`);
                // Trim if exceeds max
                if (logLines.length > LOG_MAX_LINES) {
                    const removeCount = logLines.length - LOG_MAX_LINES;
                    logLines.splice(0, removeCount);
                }

                renderLog();
                if (shouldStickToBottom) scrollToBottom();
            }

            function clearLogs() {
                logLines = [];
                renderLog();
                // ensure at top
                logContainer.scrollTop = 0;
            }

            // Re-render on scroll
            logContainer.addEventListener('scroll', renderLog);

            connection.on('ReceiveProgress', payload => {
                if (!payload || !currentJobId || payload.jobId !== currentJobId) return;
                setProgress(payload.percent || 0);
                if (payload.message) addLog(payload.message);
            });

            connection.on('ReceiveCompleted', payload => {
                if (!payload || !currentJobId || payload.jobId !== currentJobId) return;
                setProgress(100);
                addLog(payload.message || 'Completed');
                enableAll(true);
            });

            connection.on('ReceiveError', payload => {
                addLog('Error: ' + (payload?.message || 'Unknown error'));
                enableAll(true);
            });

            function enableAll(en) {
                [btnMd5, btnDuplicate, btnAvg, btnFace, btnExtractGroups, btnEmbeddingDownloader, btnAi, btnAiAnswers].forEach(b => { if (b) b.disabled = !en || b.hasAttribute('data-force-disabled'); });
            }

            (async () => {
                try { await connection.start(); addLog('Connected to hub.'); } catch (e) { addLog('Hub connection failed: ' + e); }
            })();

            connection.onreconnected(async () => {
                if (currentJobId) {
                    try {
                        await connection.invoke('JoinJobGroup', currentJobId);
                        addLog('Reconnected and rejoined job group.');
                    } catch (e) { addLog('Failed to rejoin group: ' + e); }
                } else {
                    addLog('Reconnected.');
                }
            });

            async function startJobAndWait(jobType) {
                // prepare UI
                setProgress(0);
                clearLogs();
                enableAll(false);

                const jobId = (window.crypto && crypto.randomUUID) ? crypto.randomUUID().replace(/-/g,'') : (Date.now().toString(36) + Math.random().toString(36).slice(2));
                currentJobId = jobId;
                jobIdBadge.textContent = currentJobId;
                jobIdBadge.style.display = '';

                if (connection.state !== signalR.HubConnectionState.Connected) {
                    await connection.start().catch(err => { addLog('Hub connection failed: ' + err); throw err; });
                }
                await connection.invoke('JoinJobGroup', currentJobId);
                addLog('Joined job group. Starting ' + jobType + '...');

                const completedHandler = (payload) => {
                    if (payload && payload.jobId === jobId) {
                        connection.off('ReceiveCompleted', completedHandler);
                        resolveFn();
                    }
                };
                let resolveFn;
                const p = new Promise(res => { resolveFn = res; });
                connection.on('ReceiveCompleted', completedHandler);
                const body = new URLSearchParams({ jobId: jobId, type: jobType, dop: (dopEl.value||'').toString() });
                const url = '@Url.Action("AddImagesJob", "Home")';
                const resp = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
                if (!resp.ok) {
                    addLog('Failed to start job: ' + resp.status);
                    enableAll(true);
                    connection.off('ReceiveCompleted', completedHandler);
                    throw new Error('Failed to start job');
                }
                addLog('Job started: ' + jobId);
                return p;
            }

            // Buttons
            btnMd5.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('Md5ImageMarker'); } catch {}
            });
            
            btnDuplicate.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('DuplicateMarker'); } catch {}
            });

            btnAvg.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('AverageImageMarker'); } catch {}
            });

            btnFace.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('FaceHashBuilder'); } catch {}
            });

            btnExtractGroups.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('GroupFolderExtractor'); } catch {}
            });

            btnAi.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('AiContentQueryBuilder'); } catch {}
            }); 
            
            btnAiAnswers.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('AiContentAnswerBuilder'); } catch {}
            }); 
            
            btnEmbeddingDownloader.addEventListener('click', async (e) => {
                e.preventDefault();
                try { await startJobAndWait('EmbeddingDownloader'); } catch {}
            });
            
        })();
    </script>
}
